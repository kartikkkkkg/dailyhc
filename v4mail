import sys
from pathlib import Path
from datetime import date, timedelta
import calendar
from collections import defaultdict

import pandas as pd
import numpy as np
from openpyxl import load_workbook
from openpyxl.styles import Font, Alignment, PatternFill, Border, Side
import win32com.client as win32
import ctypes

# =====================================================
# PATHS / CONFIG
# =====================================================

# Detect base directory correctly for both .py and compiled .exe
if getattr(sys, "frozen", False):
    BASE_DIR = Path(sys.executable).parent
else:
    BASE_DIR = Path(__file__).parent

RAW_DIR = BASE_DIR / "raw"
OUTPUT_DIR = BASE_DIR / "output"

# <<< CHANGE THIS TO YOUR DAILY MSTR FILE NAME >>>
CURRENT_HC_FILENAME = "Daily_HC_report_9Dec25.xlsx"  # TODO: replace with real name

CURRENT_HC_PATH = RAW_DIR / CURRENT_HC_FILENAME
LAST_HC_PATH = RAW_DIR / "hc_last_month.xlsx"
MAPPING_WB_PATH = RAW_DIR / "mapping.xlsx"

MAPPING_SHEET_NAME = "mapping"
ROLLUP_SHEET_NAME = "rollup"

OUTPUT_SHEET_NAME = "New_summary"

# Column names in HC files
COL_BANK_ID = "Bank ID"
COL_BF_L6 = "Business Function Lvl 6"
COL_EMP_TYPE_HC = "Employment Type"
COL_FTE = "FTE"

# Column names in mapping sheet
COL_MAP_BF_L6 = "Business Function Lvl 6"
COL_COST_CAT = "Cost Cat"
COL_MT_DOMAIN = "MT Domain"
COL_MT1_DOMAIN = "MT-1 Domain"
COL_MAP_EMP_TYP = "Employment Type"
COL_CONTR = "Contr/Non-Contr"

# Rollup columns
COL_ROLLUP_ID = "Employee ID"

# Contr flag values
CONTR_VALUE_CONT = "Controllable"
CONTR_VALUE_NON_CONT = "Non-Controllable"

# Summary grouping order
COST_CAT_ORDER = ["BAU", "CIO Mgmt", "TPS", "Proj"]
TOTAL_LABELS = {
    "BAU": "BAU TOTAL",
    "CIO Mgmt": "CIO MGMT TOTAL",
    "TPS": "TPS TOTAL",
    "Proj": "PROJ TOTAL",
}
GRAND_TOTAL_LABEL = "GRAND TOTAL"

# Comments threshold
COMMENT_THRESHOLD = 10


# =====================================================
# DATE LABELS
# =====================================================

def get_date_labels():
    today = date.today()
    curr_date = today - timedelta(days=1)

    if curr_date.month == 1:
        last_month = 12
        year = curr_date.year - 1
    else:
        last_month = curr_date.month - 1
        year = curr_date.year

    last_day = calendar.monthrange(year, last_month)[1]
    last_month_end = date(year, last_month, last_day)

    curr_label = curr_date.strftime("%d-%b").lstrip("0")
    last_label = last_month_end.strftime("%d-%b").lstrip("0")
    return curr_label, last_label


def get_unique_output_path(base_path: Path) -> Path:
    if not base_path.exists():
        return base_path
    i = 1
    while True:
        new_path = base_path.with_name(f"{base_path.stem}_{i}{base_path.suffix}")
        if not new_path.exists():
            return new_path
        i += 1


# =====================================================
# HELPERS
# =====================================================

def is_agency_worker(emp_type: str) -> bool:
    if not isinstance(emp_type, str):
        return False
    s = emp_type.lower()
    return "agency" in s and "worker" in s


def load_mapping_frames(mapping_wb_path: Path):
    mapping = pd.read_excel(mapping_wb_path, sheet_name=MAPPING_SHEET_NAME)
    rollup = pd.read_excel(mapping_wb_path, sheet_name=ROLLUP_SHEET_NAME)

    bf_map = mapping[
        [COL_MAP_BF_L6, COL_COST_CAT, COL_MT_DOMAIN, COL_MT1_DOMAIN]
    ].drop_duplicates()

    emp_map = mapping[
        [COL_MAP_EMP_TYP, COL_CONTR]
    ].drop_duplicates()

    return bf_map, emp_map, rollup


def apply_mappings_to_hc(hc_raw: pd.DataFrame,
                         bf_map: pd.DataFrame,
                         emp_map: pd.DataFrame) -> pd.DataFrame:
    df = hc_raw[[COL_BANK_ID, COL_BF_L6, COL_EMP_TYPE_HC, COL_FTE]].copy()
    df[COL_BANK_ID] = df[COL_BANK_ID].astype(str).str.strip()

    df = df.merge(
        bf_map,
        left_on=COL_BF_L6,
        right_on=COL_MAP_BF_L6,
        how="left",
    )

    df = df.merge(
        emp_map,
        left_on=COL_EMP_TYPE_HC,
        right_on=COL_MAP_EMP_TYP,
        how="left",
    )

    df.rename(columns={COL_CONTR: "ContrFlag"}, inplace=True)
    df["MT_CC"] = df[COL_MT_DOMAIN].astype(str) + "-" + df[COL_COST_CAT].astype(str)

    return df


def build_snapshot(df: pd.DataFrame, suffix: str) -> pd.DataFrame:
    cols = [
        COL_BANK_ID,
        "MT_CC",
        COL_COST_CAT,
        COL_MT_DOMAIN,
        COL_EMP_TYPE_HC,
        "ContrFlag",
        COL_FTE,
    ]
    snap = df[cols].copy()
    snap = snap.sort_values(COL_BANK_ID).drop_duplicates(COL_BANK_ID, keep="last")
    snap = snap.add_suffix(f"_{suffix}")
    snap.rename(columns={f"{COL_BANK_ID}_{suffix}": COL_BANK_ID}, inplace=True)
    return snap


def classify_movements(combined: pd.DataFrame, rollup_ids: set) -> pd.DataFrame:
    rows = []

    def add_move(bank_id,
                 mt_cc,
                 cost_cat,
                 mt_domain,
                 movement,
                 fte,
                 emp_type,
                 contr_side,
                 from_mt_cc=None,
                 to_mt_cc=None):
        if pd.isna(fte) or fte == 0:
            return
        rows.append(
            {
                COL_BANK_ID: bank_id,
                "MT_CC": mt_cc,
                COL_COST_CAT: cost_cat,
                COL_MT_DOMAIN: mt_domain,
                "Movement": movement,
                "FTE": float(fte),
                "EmpType": emp_type,
                "ContrSide": contr_side,
                "From_MT_CC": from_mt_cc,
                "To_MT_CC": to_mt_cc,
            }
        )

    for _, r in combined.iterrows():
        bid = r[COL_BANK_ID]

        has_last = pd.notna(r.get("MT_CC_last"))
        has_curr = pd.notna(r.get("MT_CC_curr"))

        mt_cc_last = r.get("MT_CC_last")
        mt_cc_curr = r.get("MT_CC_curr")

        cost_last = r.get(f"{COL_COST_CAT}_last")
        cost_curr = r.get(f"{COL_COST_CAT}_curr")

        mt_last = r.get(f"{COL_MT_DOMAIN}_last")
        mt_curr = r.get(f"{COL_MT_DOMAIN}_curr")

        fte_last = r.get(f"{COL_FTE}_last")
        fte_curr = r.get(f"{COL_FTE}_curr")

        emp_last = r.get(f"{COL_EMP_TYPE_HC}_last")
        emp_curr = r.get(f"{COL_EMP_TYPE_HC}_curr")

        contr_last = r.get("ContrFlag_last")
        contr_curr = r.get("ContrFlag_curr")

        # New & Non TnO
        if has_curr and not has_last:
            if bid in rollup_ids:
                movement = "Non TnO Joiners"
            else:
                movement = "New Joiners"

            add_move(
                bid,
                mt_cc_curr,
                cost_curr,
                mt_curr,
                movement,
                fte_curr,
                emp_curr,
                contr_curr,
            )

        # Left Bank
        elif has_last and not has_curr:
            add_move(
                bid,
                mt_cc_last,
                cost_last,
                mt_last,
                "Left Bank",
                fte_last,
                emp_last,
                contr_last,
            )

        # In both
        elif has_last and has_curr:
            same_mtcc = mt_cc_last == mt_cc_curr

            if same_mtcc:
                if contr_last == CONTR_VALUE_NON_CONT and contr_curr == CONTR_VALUE_CONT:
                    add_move(
                        bid,
                        mt_cc_curr,
                        cost_curr,
                        mt_curr,
                        "Conversion in",
                        fte_curr,
                        emp_curr,
                        contr_curr,
                    )
                elif contr_last == CONTR_VALUE_CONT and contr_curr == CONTR_VALUE_NON_CONT:
                    add_move(
                        bid,
                        mt_cc_curr,
                        cost_curr,
                        mt_curr,
                        "Conversion out",
                        fte_curr,
                        emp_curr,
                        contr_curr,
                    )
            else:
                # Transfer out
                add_move(
                    bid,
                    mt_cc_last,
                    cost_last,
                    mt_last,
                    "Transfer out",
                    fte_last,
                    emp_last,
                    contr_last,
                    from_mt_cc=None,
                    to_mt_cc=mt_cc_curr,
                )
                # Transfer in
                add_move(
                    bid,
                    mt_cc_curr,
                    cost_curr,
                    mt_curr,
                    "Transfer in",
                    fte_curr,
                    emp_curr,
                    contr_curr,
                    from_mt_cc=mt_cc_last,
                    to_mt_cc=None,
                )

    if not rows:
        return pd.DataFrame(
            columns=[
                COL_BANK_ID,
                "MT_CC",
                COL_COST_CAT,
                COL_MT_DOMAIN,
                "Movement",
                "FTE",
                "EmpType",
                "ContrSide",
                "From_MT_CC",
                "To_MT_CC",
            ]
        )

    return pd.DataFrame(rows)


def build_comments_for_controllable(movements: pd.DataFrame) -> pd.DataFrame:
    if movements.empty:
        return pd.DataFrame(columns=["MT_CC", "Comments"])

    df = movements[movements["ContrSide"] == CONTR_VALUE_CONT].copy()
    if df.empty:
        return pd.DataFrame(columns=["MT_CC", "Comments"])

    df["is_AW"] = df["EmpType"].apply(is_agency_worker)
    df["AW_FTE"] = np.where(df["is_AW"], df["FTE"], 0.0)
    df["FTE_FTE"] = np.where(df["is_AW"], 0.0, df["FTE"])

    totals = (
        df.groupby(["MT_CC", COL_COST_CAT, COL_MT_DOMAIN, "Movement"], as_index=False)
        .agg(
            Total_FTE=("FTE", "sum"),
            AW_FTE=("AW_FTE", "sum"),
            FTE_FTE=("FTE_FTE", "sum"),
        )
    )

    tin = (
        df[df["Movement"] == "Transfer in"]
        .dropna(subset=["From_MT_CC"])
        .groupby(["MT_CC", "From_MT_CC"], as_index=False)["FTE"]
        .sum()
    )
    tout = (
        df[df["Movement"] == "Transfer out"]
        .dropna(subset=["To_MT_CC"])
        .groupby(["MT_CC", "To_MT_CC"], as_index=False)["FTE"]
        .sum()
    )

    tin_dict = defaultdict(list)
    for _, r in tin.iterrows():
        mt_cc = r["MT_CC"]
        src = r["From_MT_CC"]
        fte = round(r["FTE"])
        if fte != 0:
            tin_dict[mt_cc].append(f"{src}={fte}")

    tout_dict = defaultdict(list)
    for _, r in tout.iterrows():
        mt_cc = r["MT_CC"]
        dst = r["To_MT_CC"]
        fte = round(r["FTE"])
        if fte != 0:
            tout_dict[mt_cc].append(f"{dst}={fte}")

    movement_order = [
        "New Joiners",
        "Non TnO Joiners",
        "Conversion in",
        "Transfer in",
        "Left Bank",
        "Conversion out",
        "Transfer out",
    ]

    rows = []
    for mt_cc, grp in totals.groupby("MT_CC"):
        grp = grp.set_index("Movement")

        def vals(m):
            if m not in grp.index:
                return 0.0, 0.0, 0.0
            row = grp.loc[m]
            return float(row["Total_FTE"]), float(row["AW_FTE"]), float(row["FTE_FTE"])

        lines = []
        for m in movement_order:
            tot, aw, fte = vals(m)
            tot_r = round(tot)
            aw_r = round(aw)
            fte_r = round(fte)

            if m == "Transfer in":
                details = tin_dict.get(mt_cc)
                if details:
                    detail_str = "; ".join(details)
                    line = f"Transfer in = {tot_r}({detail_str})"
                else:
                    line = f"Transfer in = {tot_r}"
                lines.append(line)

            elif m == "Transfer out":
                details = tout_dict.get(mt_cc)
                {}
